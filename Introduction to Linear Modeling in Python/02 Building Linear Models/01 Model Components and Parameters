Terms in a Model
Given a scatter plot of data, select the linear model that best fits the data.

To test your answer, use the predefined function plot_possible_answer(answer="X") to plot the answers, where X is one of the answers A-E.

In [11]: help(plot_possible_answer)
Help on function plot_possible_answer in module __main__:

plot_possible_answer(answer='A')
    Purpose:
        Plot one of the possible answers to help you select the best one
        Don't forget to use plt.show() after calling this function
    Args:
        answer (str): the answer you want to see, e.g. 'A' for the first of 5 listed
    Returns:
        fig (matplotlib.figure): figure object of the plot generated by this funciton
        msg (str): helpful plot description that will guide you to victory

In [15]: plot_possible_answer(answer="D")
Out[15]: (<matplotlib.figure.Figure at 0x7f24786fe8d0>, 'Answer D')

Notice that while another answer may be pretty close, if you plot_possible_answer(answer='D') you get the best allignment of the model (the red line) passing through the measured data (the black dots)


















Model Components
Previously, you have been given a pre-defined model to work with. In this exercise, you will implement a model function that returns model values for y, computed from input x data, and any input coefficients for the "zero-th" order term a0, the "first-order" term a1, and a quadratic term a2 of a model (see below).
y = a0 + a1 x + a2 x^2

Recall that "first order" is linear, so we'll set the defaults for this general linear model with a2=0, but later, we will change this for comparison.



# Define the general model as a function
def model(x, a0=3, a1=2, a2=0):
    return a0 + (a1*x) + (a2*x*x)


#Create an array of values x using the numpy method np.linspace().
# Generate array x, then predict y values for specific, non-default a0 and a1
x = np.linspace(-10, 10, 21)
y = model(x)

# Plot the results, y versus x
fig = plot_prediction(x, y)

Notice that we used model() to compute predicted values of y for given possibly measured values of x. The model takes the independent data and uses it to generate a model for the dependent variables corresponding values.

















Model Parameters
Now that you've built a general model, let's "optimize" or "fit" it to a new (preloaded) measured data set, xd, yd, by finding the specific values for model parameters a0, a1 for which the model data and the measured data line up on a plot.

This is an iterative visualization strategy, where we start with a guess for model parameters, pass them into the model(), over-plot the resulting modeled data on the measured data, and visually check that the line passes through the points. If it doesn't, we change the model parameters and try again.

In [2]: help(model)
Help on function model in module __main__:

model(x, a0=1, a1=1, a2=0)



#Complete the function plot_data_and_model(xd, yd, ym), passing xd, yd and xd, ym into the internal plotting calls.
# Complete the plotting function definition
def plot_data_with_model(xd, yd, ym):
    fig = plot_data(xd, yd)  # plot measured data
    fig.axes[0].plot(xd, ym, color='red')  # over-plot modeled data
    plt.show()
    return fig

# Select new model parameters a0, a1, and generate modeled `ym` from them.
a0 = 125
a1 = 28
ym = model(xd, a0, a1)


# Plot the resulting model to see whether it fits the data
fig = plot_data_with_model(xd, yd, ym)



Notice again that the measured x-axis data xd is used to generate the modeled y-axis data ym so to plot the model, 
you are plotting altitude (ym) vs distance (xd), which may seem counter-intuitive at first. 
But we are modeling the y response to a given x; we are not modeling x.




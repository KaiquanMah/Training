Superimpose lines
Building on the previous exercise, you will now repeat the sampling process 100 times in order to visualize the sampling distribution of regression lines generated by 100 different random samples of the population.
Rather than repeatedly calling sample_n(), like you did in the previous exercise, rep_sample_n() from the oilabs package provides a convenient way to generate many random samples. The function rep_sample_n() repeats the sample_n() command reps times.
The function do() from dplyr will allow you to run the lm call separately for each level of a variable that has been group_by'ed. Here, the group variable is the sampling replicate, so each lm is run on a different random sample of the data.

Pipe popdata to rep_sample_n(), setting the size of each sample to 50, and generating 100 reps.
# Set the seed for reproducibility
set.seed(4747)

# Repeatedly sample the population without replacement
many_samples <- popdata %>%
  rep_sample_n(reps=100, size=50)

# See the result
glimpse(many_samples)

Observations: 5,000
Variables: 3
Groups: replicate [100]
$ replicate   <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1...
$ explanatory <dbl> -3.0322454, -2.5578117, -6.3960146, -1.5946278, 3.75330...
$ response    <dbl> 31.89871, 30.05016, 27.80663, 46.05538, 33.78182, 38.26...


> head(many_samples)
# A tibble: 6 x 3
# Groups:   replicate [1]
  replicate explanatory response
      <int>       <dbl>    <dbl>
1         1      -3.03      31.9
2         1      -2.56      30.1
3         1      -6.40      27.8
4         1      -1.59      46.1
5         1       3.75      33.8
6         1       0.859     38.3

> tail(many_samples)
# A tibble: 6 x 3
# Groups:   replicate [1]
  replicate explanatory response
      <int>       <dbl>    <dbl>
1       100        1.73     54.2
2       100       -2.56     30.1
3       100        2.35     44.5
4       100       -1.03     30.6
5       100        3.41     58.2
6       100       -1.47     54.1













Using many_samples (that you created in the previous step), plot response vs. explanatory, grouped by replicate.
Add a point layer.
Add a smooth trend layer using linear regression, without a standard error ribbon.

# From previous step
set.seed(4747)
many_samples <- popdata %>% rep_sample_n(size = 50, reps = 100)


# Using many_samples, plot response vs. explanatory, grouped by replicate
ggplot(many_samples, aes(x=explanatory, y=response, group=replicate)) + 
  # Add a point layer
  geom_point() + 
  # Add a smooth trend line, using lin. reg., no ribbon
  geom_smooth(method="lm", se=FALSE) 















Again, group many_samples by replicate.
For each replicate, run the model then tidy it. Inside do(), call lm() with the usual model formula: response vs. explanatory. The data argument is simply .. Pipe this to tidy().
Filter for rows where term equals "explanatory".

#before filtering for rows regarding explanatory terms only
many_samples %>% 
  # Group by replicate
  group_by(replicate) %>% 
  # Run the model on each replicate, then tidy it
  do(lm(response ~ explanatory, data = .) %>% tidy())
  
# A tibble: 200 x 6
# Groups:   replicate [100]
   replicate term        estimate std.error statistic  p.value
       <int> <chr>          <dbl>     <dbl>     <dbl>    <dbl>
 1         1 (Intercept)    39.1      1.41      27.7  3.84e-31
 2         1 explanatory     1.88     0.361      5.21 3.95e- 6
 3         2 (Intercept)    41.9      1.11      37.7  2.68e-37
 4         2 explanatory     1.80     0.231      7.76 5.15e-10
 5         3 (Intercept)    39.4      1.68      23.5  6.11e-28
 6         3 explanatory     2.12     0.322      6.58 3.19e- 8
 7         4 (Intercept)    41.8      1.39      30.1  7.95e-33
 8         4 explanatory     1.88     0.282      6.65 2.50e- 8
 9         5 (Intercept)    38.8      1.28      30.3  6.09e-33
10         5 explanatory     1.96     0.229      8.58 3.00e-11
# ... with 190 more rows  




# From previous step
set.seed(4747)
many_samples <- popdata %>% rep_sample_n(size = 50, reps = 100)

many_lms <- many_samples %>% 
  # Group by replicate
  group_by(replicate) %>% 
  # Run the model on each replicate, then tidy it
  do(lm(response ~ explanatory, data = .) %>% tidy()) %>%
  # Filter for rows where the term is explanatory
  filter(term=="explanatory")

# See the result
many_lms

# A tibble: 100 x 6
# Groups:   replicate [100]
   replicate term        estimate std.error statistic  p.value
       <int> <chr>          <dbl>     <dbl>     <dbl>    <dbl>
 1         1 explanatory     1.88     0.361      5.21 3.95e- 6
 2         2 explanatory     1.80     0.231      7.76 5.15e-10
 3         3 explanatory     2.12     0.322      6.58 3.19e- 8
 4         4 explanatory     1.88     0.282      6.65 2.50e- 8
 5         5 explanatory     1.96     0.229      8.58 3.00e-11
 6         6 explanatory     2.67     0.367      7.26 2.96e- 9
 7         7 explanatory     2.18     0.262      8.30 7.71e-11
 8         8 explanatory     2.19     0.254      8.65 2.37e-11
 9         9 explanatory     2.07     0.344      6.04 2.21e- 7
10        10 explanatory     2.15     0.254      8.44 4.81e-11
# ... with 90 more rows










Using many_lms, plot estimate.
Add a histogram layer using geom_histogram().
# Using many_lms, plot estimate
ggplot(many_lms, aes(x=estimate)) +
  # Add a histogram layer
  geom_histogram()

By generating many replicates and running the model on each one, you get a distribution of the model coefficients, allowing you to calculate confidence intervals.


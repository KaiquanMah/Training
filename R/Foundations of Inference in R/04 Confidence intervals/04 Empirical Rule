Empirical Rule
Many statistics we use in data analysis (including both the sample average and sample proportion) have nice properties that are used to better understand the population parameter(s) of interest.

One such property is that if the variability of the sample proportion (called the standard error, or SE) is known, then approximately 95% of p^ values (from different samples) will be within 2SE of the true population proportion.

To check whether that holds in the situation at hand, let's go back to the polls generated by taking many samples from the same population.

The all_polls dataset contains 1000 samples of size 30 from a population with a probability of voting for Candidate X equal to 0.6.

Note that you will use the R function sd() which calculates the variability of any set of numbers. In statistics, when sd() is applied to a variable (e.g., price of house) we call it the standard deviation. When sd() is applied to a statistic (e.g., set of sample proportions) we call it the standard error.




Run the code to generate props, the proportion of individuals who are planning to vote yes in each poll. This is based upon ex1_props from previous exercises.
Add a column, is_in_conf_int that is TRUE when the sampled proportion of yes votes is less than 2 standard errors away from the true population proportion of yes votes. That is, the abs()solute difference between prop_yes and true_prop_yes is less than twice sd() of prop_yes.
Calculate the proportion of sample statistics in the confidence interval, prop_in_conf_int, by taking the mean() of is_in_conf_int.


> props
# A tibble: 1,000 x 2
    poll prop_yes
   <int>    <dbl>
 1     1    0.7  
 2     2    0.667
 3     3    0.633
 4     4    0.633
 5     5    0.4  
 6     6    0.6  
 7     7    0.5  
 8     8    0.533
 9     9    0.567
10    10    0.567
# ... with 990 more rows



> props %>%
    # Add column: is prop_yes in 2SE of 0.6
    mutate(is_in_conf_int = abs(prop_yes - true_prop_yes) < 2 * sd(prop_yes))
# A tibble: 1,000 x 3
    poll prop_yes is_in_conf_int
   <int>    <dbl> <lgl>         
 1     1    0.7   TRUE          
 2     2    0.667 TRUE          
 3     3    0.633 TRUE          
 4     4    0.633 TRUE          
 5     5    0.4   FALSE         
 6     6    0.6   TRUE          
 7     7    0.5   TRUE          
 8     8    0.533 TRUE          
 9     9    0.567 TRUE          
10    10    0.567 TRUE          
# ... with 990 more rows






# Proportion of yes votes by poll
props <- all_polls %>% 
  group_by(poll) %>% 
  summarize(prop_yes = mean(vote == "yes"))

# The true population proportion of yes votes
true_prop_yes <- 0.6

# Proportion of polls within 2SE
props %>%
  # Add column: is prop_yes in 2SE of 0.6
  mutate(is_in_conf_int = abs(prop_yes - true_prop_yes) < 2 * sd(prop_yes)) %>%
  # Calculate  proportion in conf int
  summarize(prop_in_conf_int = mean(is_in_conf_int))


# A tibble: 1 x 1
  prop_in_conf_int
             <dbl>
1            0.966





In this example, it looks like 96.6% are within 2 standard errors of the true population parameter.


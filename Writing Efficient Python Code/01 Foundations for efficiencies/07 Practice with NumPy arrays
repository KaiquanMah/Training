Practice with NumPy arrays
Let's practice slicing numpy arrays and using NumPy's broadcasting concept. Remember, broadcasting refers to a numpy array's ability to vectorize operations, so they are performed on all elements of an object at once.
A two-dimensional numpy array has been loaded into your session (called nums) and printed into the console for your convenience. numpy has been imported into your session as np.
[[ 1  2  3  4  5]
 [ 6  7  8  9 10]]


Print the second row of nums.
Print the items of nums that are greater than six.
Create nums_dbl that doubles each number in nums.
Replace the third column in nums with a new column that adds 1 to each item in the original column.

# Print second row of nums
print(nums[1, :])

<script.py> output:
    [ 6  7  8  9 10]
    
    
    
# Print all elements of nums that are greater than six
print(nums[nums > 6])

<script.py> output:
    [ 7  8  9 10]




# Double every element of nums
nums_dbl = nums * 2
print(nums_dbl)

<script.py> output:
    [[ 2  4  6  8 10]
     [12 14 16 18 20]]





# Replace the third column of nums
nums[:, 2] += 1
print(nums)

<script.py> output:
    [[ 1  2  4  4  5]
     [ 6  7  9  9 10]]
     
     
     









When compared to a list object, what are two advantages of using a numpy array?
[[ 1  2  3  4  5]
 [ 6  7  8  9 10]]

A numpy array is the only data structure that can be used with the numpy package and often has less verbose indexing syntax.
A numpy array supports boolean indexing and has much better one-dimensional indexing capabilities.
Both a list object and a numpy array are identical.

#YES - A numpy array contains homogeneous data types (which reduces memory consumption) and provides the ability to apply operations on all elements through broadcasting.
Well done! You're slicing numpy arrays like a pro and learning how to take advantage of NumPy's broadcasting concept. Using numpy arrays allows you to take advantage of an array's memory efficient nature and easily perform mathematical operations on your data.



